<!DOCTYPE html> 
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IsoArcade</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <script src="script.js"></script>
    <script> function goToMainMenu() {window.location.href = "index.html";}</script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <button id="backButton" onclick="goToMainMenu()">> main_menu</button>
    <div class="content">
        <p>
            ISOARCADE | 21-06-2025
        </p>
        <div class="images">
            <img src="assets/images/pixel_art/isoarcade.png" alt="Logo of IsoArcade">
        </div>
        <p>
            ¤ part 0: Introduction
            <br><br>
            I am making a JS library for creating isometric games in browser called IsoArcade.
            This is so I can create my own video game, and make it easier for others to make isometric games. 
            You can view my work so far on <a href="https://github.com/maher14879/IsoArcade" target="_blank">github</a> or see the working prototype <a href="iso_arcade_prototype.html" target="_blank">Iso Arcade Prototype</a> (move around using WASD) 
            I am still working on this project, so the following chapters are still a work in progress.
            <br><br>
            ¤ part 1: Isometric Tiling
            <br><br>
            In true isometric drawing, the front corner of a voxel would be in the exact same line of sight as the back corner.
            My library allows for any non-perspective drawing of a voxel in coords \((x', y')\) based on the formula:
            \[x' =  \frac{w}{2} (x - y) \]
            \[y' = -z (h - 2o) + (x + y) o,\]
            where w, h are the width and height of the voxel texture and o is the offset of the front corner and back corner in pixels.
            Each solid voxel is also split into 3 sides (one for each visible axis).
            This allows each voxel to have a separate light level for each side.
            <br><br>
            ¤ part 2: Sorting the voxels
            <br><br>
            Most voxels cannot be drawn at the same time and must be sorted in order of z position, then we must order each pair of voxels in terms of \(x_1 + x_2 - (y_1 + y_2)\). 
            We would also like to remove all voxels that are covered by a solid voxel.
            This is done by first calculating the direction vector of the voxel \((y - x, z - x)\) and the magnitude of that vector \(x + y + z\).
            Then we only draw the solid voxels with the highest magnitude and any non-solid voxel with a higher magnitude.
            <br><br>
            ¤ part 3: Chunks
            <br><br>
            Chunks are essential for loading and saving parts of open world games.
            Minecraft use a 16x16 chunk system, which I also did. 
            This is because it saves time when determining which chunk a voxel belongs to.
            This is because for a value \(x\), we have that 
            \[\left\lfloor \frac{x}{y} \right\rfloor = x \gg \log_2{y}\]
            if \(y\) is even and a power of \(2\).
            Since \(\log_2{16}=4\), we can bitshift any number by \(4\) and get the chunk index of that coordinate. 
            I also implemented a system for soft loading chunks to avoid chunk-border light issues.
            <br><br>
            ¤ part 4: Light Propagation
            <br><br>
        </p>
    </div>
</body>
</html>

