<!DOCTYPE html> 
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IsoArcade</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <script src="script.js"></script>
    <script> function goToMainMenu() {window.location.href = "index.html";}</script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <button id="backButton" onclick="goToMainMenu()">> main_menu</button>
    <div class="content">
        <p>
            ISOARCADE | 21-06-2025
        </p>
        <div class="images">
            <img src="assets/images/pixel_art/isoarcade.png" alt="Logo of IsoArcade">
        </div>
        <p>
            ¤ part 0: Introduction
            <br><br>
            I am making a JS library for creating isometric games in browser called IsoArcade.
            This is so I can create my own video game, and make it easier for others to make isometric games. 
            You can view my work so far on <a href="https://github.com/maher14879/IsoArcade" target="_blank">github</a> or see the working prototype <a href="iso_arcade_prototype.html" target="_blank">Iso Arcade Prototype</a> (move around by pressing the scroll wheel on your mouse, use right-click to place light source, left_click to break voxel and press Q to flip perspective) 
            I am still working on this project, so the following chapters are still a work in progress.
            <br><br>
            ¤ part 1: Isometric Tiling
            <br><br>
            In true isometric drawing, the front corner of a voxel would be in the exact same line of sight as the back corner.
            My library allows for any non-perspective drawing of a voxel in coords \((x', y')\) based on the formula:
            \[x' =  \frac{w}{2} (x - y) \]
            \[y' = -z (h - 2o) + (x + y) o,\]
            where \(w\) and \(h\) are the width and height of the voxel texture and \(o\) is the offset of in the perspective in pixels compared to kardinal perspective.
            Each solid voxel is also split into 3 sides (one for each visible axis).
            This allows each voxel to have a separate light level for each side.
            <br><br>
            ¤ part 2: Sorting the voxels
            <br><br>
            Most voxels cannot be drawn at the same time and must be sorted in order of z position, then we must order each pair of voxels in terms of \(x_1 + x_2 - (y_1 + y_2)\). 
            We would also like to remove all voxels that are covered by a solid voxel.
            This is done by first calculating the direction vector of the voxel \((y - x, z - x)\) and the magnitude of that vector \(x + y + z\).
            Then we only draw the solid voxels with the highest magnitude and any non-solid voxel with a higher magnitude.
            <br><br>
            ¤ part 3: Chunks
            <br><br>
            Chunks are essential for loading and saving parts of open world games.
            Minecraft use a 16x16 chunk system, which I also did. 
            This is because it saves time when determining which chunk a voxel belongs to.
            This is because for a value \(x\), we have that 
            \[\left\lfloor \frac{x}{y} \right\rfloor = x \gg \log_2{y}\]
            if \(y\) is even and a power of \(2\).
            Since \(\log_2{16}=4\), we can bitshift any number by \(4\) and get the chunk index of that coordinate. 
            I also implemented a system for soft loading chunks to avoid chunk-border light issues.
            <br><br>
            ¤ part 4: Light Propagation
            <br><br>
            Using 3d floodfill, where each movement reduces the light level and then lighting each voxel face reached, we can add realistic lighting.
            By having directional attenuation, we can have raytrace-like lighting, since moveing around a corner would affect the light fall off even more.
            All lights are saved for each chunk. 
            Whenever a voxel is placed or removed in a chunk, we propogate negative light from all lights in that chunk and all neighboring chunks that have a distance lower or equal to their light level. 
            We then place or remove the voxel, and repropogate the lights.
            <br><br>
            ¤ part 5: Interacting with the World
            <br><br>
            For camera movement we rotate the cardinal axis of the intended movement, so they are on the diagonals instead.
            This is because isometric projection shifts the view, so the diagonals of voxels are facing towards you. 
            To get which voxel, and what side of that voxel, the mouse is hovering at, we must first get the position of the mouse inside the voxel texture.
            Let that position be \(P=(dx, dy)\).
            For the \(x\) axis side, we must first test if \(dx \ge \frac w 2 \wedge dy \ge o\).
            Then we must test if the point is in either one of the two triangles that are not included in the texture.
            We do that by defining the triangle points as \(A=(0, o)\), \(B=(\frac w 2, o)\) and \(C=(\frac w 2, 2o)\) for the top triangle.
            To then test if the point is not in triangle \(ABC\) we find the signed values,
            \[
            \begin{aligned}
            d_1 &= \operatorname{sign}(P, A, B) = (dx - B_x)(A_y - B_y) - (A_x - B_x)(dy - B_y) \\
            d_2 &= \operatorname{sign}(P, B, C) = (dx - C_x)(B_y - C_y) - (B_x - C_x)(dy - C_y) \\
            d_3 &= \operatorname{sign}(P, C, A) = (dx - A_x)(C_y - A_y) - (C_x - A_x)(dy - A_y)
            \end{aligned}
            \]
            that gives us the following expression for if the point is outside the triangle
            \[(d_1 < 0 \lor d_2 < 0 \lor d_3 < 0) \land (d_1 > 0 \lor d_2 > 0 \lor d_3 > 0).\]
            Doing something similar for the \(y\) and \(z\) axis, the user can place and destroy voxels from a given player input.
            <br><br>
            ¤ part 6: Rotating the View
            <br><br>
            Coming right up
            <br><br>
            ¤ part 7: Voxel States and Animation
            <br><br>
            Coming right up
            <br><br>
        </p>
    </div>
</body>
</html>

